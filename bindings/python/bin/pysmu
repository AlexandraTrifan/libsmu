#!/usr/bin/env python

"""Utility for managing M1K devices.

This script provides similar support to the smu command-line utility mostly to
provide examples for how to leverage the pysmu bindings.
"""

from __future__ import print_function

import argparse
from collections import OrderedDict
from itertools import chain
import os
import signal
from signal import signal, SIG_DFL, SIGINT
import sys
import time

import pysmu


if __name__ == '__main__':
    signal(SIGINT, SIG_DFL)

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    mux = parser.add_mutually_exclusive_group()
    mux.add_argument(
        '-d', '--display-calibration', action='store_true', dest='display',
        help='display calibration data from a device')
    mux.add_argument(
        '-r', '--reset-calibration', action='store_true', dest='reset',
        help='reset calibration data on a device to the defaults')
    mux.add_argument(
        '-w', '--write-calibration', metavar='PATH_TO_CAL_FILE', dest='write',
        help='write calibration data to a device')
    mux.add_argument(
        '-f', '--flash', metavar='PATH_TO_FIRMWARE', dest='firmware',
        help='flash firmware image to a device')
    mux.add_argument(
        '-p', '--hotplug', action='store_true',
        help='flash firmware image to a device')
    mux.add_argument(
        '--version', action='version',
        version='pysmu {}, (libsmu {})'.format(pysmu.__version__, pysmu.libsmu.__version__))

    options = parser.parse_args()
    if not any(vars(options).values()):
        parser.error('at least one argument must be specified')

    session = pysmu.Session()
    session.add_all()
    if not session.devices:
        sys.stderr.write("No supported devices are plugged in.\n")
        sys.exit(1)

    dev = session.devices[0]

    if options.write is not None:
        if not os.path.exists(options.write):
            parser.error("calibration file doesn't exist: {}".format(options.write))
        try:
            dev.write_calibration(options.write)
        except (ValueError, RuntimeError) as e:
            print("calibration failed: {}".format(e.message))
            sys.exit(1)
        print("successfully updated calibration")
    elif options.reset:
        try:
            dev.write_calibration(None)
        except (ValueError, RuntimeError) as e:
            print("calibration failed: {}".format(e.message))
            sys.exit(1)
        print("successfully reset calibration")
    elif options.display:
        cal_str_map = {
            0: 'Channel A, measure V',
            1: 'Channel A, measure I',
            2: 'Channel A, source V',
            3: 'Channel A, source I',
            4: 'Channel B, measure V',
            5: 'Channel B, measure I',
            6: 'Channel B, source V',
            7: 'Channel B, source I',
        }

        for i, vals in enumerate(dev.calibration):
            print(cal_str_map[i])
            print("  offset: {:.4f}".format(vals[0]))
            print("  p gain: {:.4f}".format(vals[1]))
            print("  n gain: {:.4f}".format(vals[2]))
    elif options.firmware:
        session.flash_firmware(options.firmware)
    elif options.hotplug:
        def attached(dev):
            print('device attached: serial {}: fw {}'.format(dev.serial, dev.fwver))

        def detached(dev):
            print('device detached: serial {}: fw {}'.format(dev.serial, dev.fwver))

        session.hotplug_attach(attached)
        session.hotplug_detach(detached)

        print('waiting for hotplug events...')
        while True:
            time.sleep(1)
