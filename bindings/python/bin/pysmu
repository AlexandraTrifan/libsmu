#!/usr/bin/env python

"""Utility for managing M1K devices.

This script provides similar support to the smu command-line utility mostly to
provide examples for how to leverage the pysmu bindings.
"""

from __future__ import print_function

import argparse
from collections import OrderedDict
from itertools import chain
import json
import os
import signal
from signal import signal, SIG_DFL, SIGINT
import sys
import tempfile
import time
from urllib import urlretrieve
import urllib2

import pysmu

def pprint(s, **kwargs):
    """Prefix output with program name."""
    print('{}: {}'.format(os.path.basename(__file__), s), **kwargs)

def calibration(session, args):
    """Read, write, or reset device calibration."""

    if not session.devices:
        pprint('no supported devices are plugged in', file=sys.stderr)
        sys.exit(1)

    dev = session.devices[0]

    if args.display:
        cal_str_map = {
            0: 'Channel A, measure V',
            1: 'Channel A, measure I',
            2: 'Channel A, source V',
            3: 'Channel A, source I',
            4: 'Channel B, measure V',
            5: 'Channel B, measure I',
            6: 'Channel B, source V',
            7: 'Channel B, source I',
        }

        for i, vals in enumerate(dev.calibration):
            print(cal_str_map[i])
            print("  offset: {:.4f}".format(vals[0]))
            print("  p gain: {:.4f}".format(vals[1]))
            print("  n gain: {:.4f}".format(vals[2]))

    else:
        cal_path = None
        if args.write is not None:
            cal_path = args.write
            if not os.path.exists(cal_path):
                pprint("calibration file doesn't exist: {}".format(cal_path))
                sys.exit(1)

        try:
            dev.write_calibration(args.write)
        except pysmu.DeviceError as e:
            pprint(str(e))
            sys.exit(1)
        pprint("successfully updated calibration")


def list_devices(session, args):
    """List all devices in a session."""
    for i, dev in enumerate(session.devices):
        print('device {}: {}'.format(i, dev))


def stream_data(session, args):
    """Stream data from an attached device."""
    if session.devices:
        dev = session.devices[0]
        # Ignore read buffer overflows when printing to stdout.
        dev.ignore_dataflow = sys.stdout.isatty()
        dev.channels['A'].mode = pysmu.Mode.HI_Z
        dev.channels['B'].mode = pysmu.Mode.HI_Z
        session.start(0)

        while True:
            for x in dev.samples:
                print("{:6f} {:6f} {:6f} {:6f}".format(x[0][0], x[0][1], x[1][0], x[1][1]))
    else:
        pprint('no devices attached')
        sys.exit(1)


def hotplug(session, args):
    """Simple hotplug testing method."""
    def attached(dev):
        print('device attached: {}'.format(dev))

    def detached(dev):
        print('device detached: {}'.format(dev))

    session.hotplug_attach(attached)
    session.hotplug_detach(detached)

    pprint('waiting for hotplug events...')
    while True:
        time.sleep(1)


def flash(session, args):
    """Flash a device's firmware."""
    flashed = False
    fw_url = None
    version = None
    github_fw_releases = 'https://api.github.com/repos/analogdevicesinc/m1k-fw/releases'
    dev_fw_url = 'https://github.com/analogdevicesinc/m1k-fw/raw/master/m1000.bin'

    if args.firmware_path is not None:
        try:
            session.flash_firmware(args.firmware_path)
            flashed = True
        except pysmu.SessionError as e:
            pprint(str(e))
            sys.exit(1)
    elif args.flash_auto or args.list_releases or args.select_release is not None:
        resp = urllib2.urlopen(github_fw_releases)
        releases = json.load(resp)
        if not releases or not releases[0]['assets']:
            pprint("no firmware releases available on github")
            sys.exit(1)
        else:
            if args.list_releases:
                valid_releases = []
                for release in releases:
                    for x in release['assets']:
                        if x['name'] == 'm1000.bin':
                            valid_releases.append(release)
                            break
                if valid_releases:
                    pprint('available firmware releases: {}'.format(
                        ', '.join(x['tag_name'] for x in valid_releases)))
                else:
                    pprint('no valid firmware file releases (m1000.bin) on github')
            else:
                if args.select_release is not None:
                    if args.select_release == 'dev':
                        # use the latest fw checked into the repo
                        fw_url = dev_fw_url
                        version = 'dev'
                    else:
                        selected_version = 'v' + args.select_release.lstrip('v')
                        try:
                            selected = next(x for x in releases if x['tag_name'] == selected_version)
                        except StopIteration:
                            pprint("no such firmware version available on github: {}".format(selected_version))
                            sys.exit(1)
                else:
                    # choose the newest release
                    selected = releases[0]

                if fw_url is None:
                    fw_assets = [x for x in selected['assets'] if x['name'] == 'm1000.bin']
                    if not fw_assets:
                        pprint("no firmware file (m1000.bin) for the release on github")
                        sys.exit(1)
                    fw_url = fw_assets[0]['browser_download_url']

                if version is None:
                    version = selected['tag_name']

                pprint('updating to github release: {}'.format(version))
                temp_fw = tempfile.NamedTemporaryFile().name
                urlretrieve(fw_url, temp_fw)
                try:
                    session.flash_firmware(temp_fw)
                except pysmu.SessionError as e:
                    pprint(str(e))
                    sys.exit(1)
                finally:
                    os.remove(temp_fw)
                flashed = True

    if flashed:
        pprint('successfully updated firmware, please unplug and replug the device(s)')


if __name__ == '__main__':
    signal(SIGINT, SIG_DFL)

    parser = argparse.ArgumentParser(
        description=__doc__,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(help='available commands')
    parser.add_argument(
        '--version', action='version',
        version='pysmu {}, (libsmu {})'.format(pysmu.__version__, pysmu.libsmu.__version__))

    parser_cal = subparsers.add_parser(
        'cal',
        description='display, reset, or write calibration data',
        help='modify calibration data')
    parser_cal.set_defaults(func=calibration)
    parser_cal_mux = parser_cal.add_mutually_exclusive_group()
    parser_cal_mux.add_argument(
        '-d', '--display', action='store_true', dest='display',
        help='display calibration data from a device')
    parser_cal_mux.add_argument(
        '-r', '--reset', action='store_true', dest='reset',
        help='reset calibration data on a device to the defaults')
    parser_cal_mux.add_argument(
        '-w', '--write', metavar='PATH_TO_CAL_FILE', dest='write',
        help='write calibration data to a device')

    parser_list = subparsers.add_parser(
        'list',
        description='list supported devices attached to the system',
        help='list devices')
    parser_list.set_defaults(func=list_devices)

    parser_hotplug = subparsers.add_parser(
        'hotplug',
        description='simple session device hotplug testing',
        help='hotplug devices')
    parser_hotplug.set_defaults(func=hotplug)

    parser_flash = subparsers.add_parser(
        'flash',
        description='flash firmware image to a device',
        help='flash firmware')
    parser_flash.set_defaults(func=flash)
    parser_flash_mux = parser_flash.add_mutually_exclusive_group()
    parser_flash_mux.add_argument(
        '-a', '--auto', action='store_true', dest='flash_auto',
        help='update to the latest firmware release from github (requires network access)')
    parser_flash_mux.add_argument(
        '-f', dest='firmware_path',
        help='update via a specified firmware file')
    parser_flash_mux.add_argument(
        '-l', action='store_true', dest='list_releases',
        help='list available firmware releases on github')
    parser_flash_mux.add_argument(
        '-v', dest='select_release', metavar='VERSION',
        help='select available firmware release on github to flash')

    parser_stream = subparsers.add_parser(
        'stream',
        description='stream data from an attached device',
        help='stream data')
    parser_stream.set_defaults(func=stream_data)

    args = parser.parse_args()

    # default to displaying calibration data if no subcommand is selected
    if args.func.__name__ == 'calibration':
        if (all(not getattr(args, x) for x in ('display', 'reset', 'write'))):
            args.display = True

    # default to auto-flashing if no option is selected
    if args.func.__name__ == 'flash':
        if (all(not getattr(args, x) for x in (
                'firmware_path', 'flash_auto',
                'list_releases', 'select_release'))):
            args.flash_auto = True

    session = pysmu.Session()
    args.func(session, args)
