<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>libsmu: smu::Session Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libsmu
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
   <div id="projectbrief">Library for interfacing with ADALM1000 devices</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>smu</b></li><li class="navelem"><a class="el" href="classsmu_1_1Session.html">Session</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsmu_1_1Session-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">smu::Session Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Generic session class.  
 <a href="classsmu_1_1Session.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acc70d95d0c0e95be86eb5f4e1969b178"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#acc70d95d0c0e95be86eb5f4e1969b178">scan</a> ()</td></tr>
<tr class="memdesc:acc70d95d0c0e95be86eb5f4e1969b178"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scan system for all supported devices. Updates the list of available, supported devices for the session (m_available_devices).  <a href="#acc70d95d0c0e95be86eb5f4e1969b178">More...</a><br /></td></tr>
<tr class="separator:acc70d95d0c0e95be86eb5f4e1969b178"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9004a90c79aeb7ea72d673a0eb80c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#acf9004a90c79aeb7ea72d673a0eb80c6">add</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device)</td></tr>
<tr class="memdesc:acf9004a90c79aeb7ea72d673a0eb80c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a device to the session. This method may not be called while the session is active.  <a href="#acf9004a90c79aeb7ea72d673a0eb80c6">More...</a><br /></td></tr>
<tr class="separator:acf9004a90c79aeb7ea72d673a0eb80c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08380597da395595965e7c118e96619b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a08380597da395595965e7c118e96619b">add_all</a> ()</td></tr>
<tr class="memdesc:a08380597da395595965e7c118e96619b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shim to add all available devices to a session. This method may not be called while the session is active.  <a href="#a08380597da395595965e7c118e96619b">More...</a><br /></td></tr>
<tr class="separator:a08380597da395595965e7c118e96619b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84af66d26dcf13f1ffd4c3319bb1acf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a84af66d26dcf13f1ffd4c3319bb1acf8">get_device</a> (const char *serial)</td></tr>
<tr class="memdesc:a84af66d26dcf13f1ffd4c3319bb1acf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the device matching a given serial from the session.  <a href="#a84af66d26dcf13f1ffd4c3319bb1acf8">More...</a><br /></td></tr>
<tr class="separator:a84af66d26dcf13f1ffd4c3319bb1acf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae974dbd0a50bb0d3b62f327276f07515"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ae974dbd0a50bb0d3b62f327276f07515">remove</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device)</td></tr>
<tr class="memdesc:ae974dbd0a50bb0d3b62f327276f07515"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from the session.  <a href="#ae974dbd0a50bb0d3b62f327276f07515">More...</a><br /></td></tr>
<tr class="separator:ae974dbd0a50bb0d3b62f327276f07515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d2d4a00c48cd30453a843f267ef49d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a3d2d4a00c48cd30453a843f267ef49d4">destroy</a> (<a class="el" href="classsmu_1_1Device.html">Device</a> *device)</td></tr>
<tr class="memdesc:a3d2d4a00c48cd30453a843f267ef49d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a device from the list of available devices.  <a href="#a3d2d4a00c48cd30453a843f267ef49d4">More...</a><br /></td></tr>
<tr class="separator:a3d2d4a00c48cd30453a843f267ef49d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894b5e950deb4a5104a12c73cbfd91c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a894b5e950deb4a5104a12c73cbfd91c2">configure</a> (uint64_t sampleRate)</td></tr>
<tr class="memdesc:a894b5e950deb4a5104a12c73cbfd91c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Configure the session's sample rate.  <a href="#a894b5e950deb4a5104a12c73cbfd91c2">More...</a><br /></td></tr>
<tr class="separator:a894b5e950deb4a5104a12c73cbfd91c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e7b6d5f7617306ea547c3cb574a351"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aa2e7b6d5f7617306ea547c3cb574a351">run</a> (uint64_t samples)</td></tr>
<tr class="memdesc:aa2e7b6d5f7617306ea547c3cb574a351"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the currently configured capture and wait for it to complete.  <a href="#aa2e7b6d5f7617306ea547c3cb574a351">More...</a><br /></td></tr>
<tr class="separator:aa2e7b6d5f7617306ea547c3cb574a351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f53f67b1ba9bf64b3d9b7010fa9a2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a89f53f67b1ba9bf64b3d9b7010fa9a2b">start</a> (uint64_t samples)</td></tr>
<tr class="memdesc:a89f53f67b1ba9bf64b3d9b7010fa9a2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the currently configured capture, but do not wait for it to complete.  <a href="#a89f53f67b1ba9bf64b3d9b7010fa9a2b">More...</a><br /></td></tr>
<tr class="separator:a89f53f67b1ba9bf64b3d9b7010fa9a2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d2654f6a32cf70410a59fbecfce29be"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5d2654f6a32cf70410a59fbecfce29be"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a5d2654f6a32cf70410a59fbecfce29be">cancel</a> ()</td></tr>
<tr class="memdesc:a5d2654f6a32cf70410a59fbecfce29be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cancel capture and block waiting for it to complete. <br /></td></tr>
<tr class="separator:a5d2654f6a32cf70410a59fbecfce29be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a0a4fc6bf82a0b11fa8b824136b36cdab">cancelled</a> ()</td></tr>
<tr class="memdesc:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the cancellation status of a session.  <a href="#a0a4fc6bf82a0b11fa8b824136b36cdab">More...</a><br /></td></tr>
<tr class="separator:a0a4fc6bf82a0b11fa8b824136b36cdab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3538a3cff8a463ba7ee89efe2e29485a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a3538a3cff8a463ba7ee89efe2e29485a">flash_firmware</a> (const char *file, <a class="el" href="classsmu_1_1Device.html">Device</a> *device=NULL)</td></tr>
<tr class="memdesc:a3538a3cff8a463ba7ee89efe2e29485a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update device firmware for a given device.  <a href="#a3538a3cff8a463ba7ee89efe2e29485a">More...</a><br /></td></tr>
<tr class="separator:a3538a3cff8a463ba7ee89efe2e29485a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afcdbec2e66e9478ca83c3d4c88a5e0cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#afcdbec2e66e9478ca83c3d4c88a5e0cd">completion</a> ()</td></tr>
<tr class="memdesc:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by devices on the USB thread when they are complete. <br /></td></tr>
<tr class="separator:afcdbec2e66e9478ca83c3d4c88a5e0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abf0e885ab8d46fc1793a75c35c5ec6f7"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#abf0e885ab8d46fc1793a75c35c5ec6f7">handle_error</a> (int status, const char *tag)</td></tr>
<tr class="memdesc:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by devices on the USB thread when a device encounters an error. <br /></td></tr>
<tr class="separator:abf0e885ab8d46fc1793a75c35c5ec6f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab25f187c532e0654019fff37865f935"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aab25f187c532e0654019fff37865f935"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#aab25f187c532e0654019fff37865f935">attached</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:aab25f187c532e0654019fff37865f935"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by device attach events on the USB thread. <br /></td></tr>
<tr class="separator:aab25f187c532e0654019fff37865f935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4483e84ebed73d4e62e3730306c73be3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4483e84ebed73d4e62e3730306c73be3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a4483e84ebed73d4e62e3730306c73be3">detached</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a4483e84ebed73d4e62e3730306c73be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">internal: Called by device detach events on the USB thread. <br /></td></tr>
<tr class="separator:a4483e84ebed73d4e62e3730306c73be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc5ea531814e08dbcb4b2908a9b6b03"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abcc5ea531814e08dbcb4b2908a9b6b03"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#abcc5ea531814e08dbcb4b2908a9b6b03">wait_for_completion</a> ()</td></tr>
<tr class="memdesc:abcc5ea531814e08dbcb4b2908a9b6b03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all devices have are finished streaming in the session. <br /></td></tr>
<tr class="separator:abcc5ea531814e08dbcb4b2908a9b6b03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27549d952e18e7561e2a16fe8800273a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a27549d952e18e7561e2a16fe8800273a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a27549d952e18e7561e2a16fe8800273a">end</a> ()</td></tr>
<tr class="memdesc:a27549d952e18e7561e2a16fe8800273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Block until all devices have completed, then turn off the devices. <br /></td></tr>
<tr class="separator:a27549d952e18e7561e2a16fe8800273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad93d557beed66a6f678c41ed01a1d0c9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad93d557beed66a6f678c41ed01a1d0c9"></a>
std::vector&lt; std::shared_ptr&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ad93d557beed66a6f678c41ed01a1d0c9">m_available_devices</a></td></tr>
<tr class="memdesc:ad93d557beed66a6f678c41ed01a1d0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devices that are present on the system. Note that these devices consist of all supported devices currently recognized on the system; however, the devices aren't necessarily bound to a session. In order to add devices to a session, <a class="el" href="classsmu_1_1Session.html#acf9004a90c79aeb7ea72d673a0eb80c6" title="Add a device to the session. This method may not be called while the session is active. ">add()</a> must be used. <br /></td></tr>
<tr class="separator:ad93d557beed66a6f678c41ed01a1d0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1ed604b80d9b49ee18dbcbbb3d8921d0"></a>
std::set&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a1ed604b80d9b49ee18dbcbbb3d8921d0">m_devices</a></td></tr>
<tr class="memdesc:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devices that are part of this session. These devices will be started when <a class="el" href="classsmu_1_1Session.html#a89f53f67b1ba9bf64b3d9b7010fa9a2b" title="Start the currently configured capture, but do not wait for it to complete. ">start()</a> is called. Use <code><a class="el" href="classsmu_1_1Session.html#acf9004a90c79aeb7ea72d673a0eb80c6" title="Add a device to the session. This method may not be called while the session is active. ">add()</a></code> and <code><a class="el" href="classsmu_1_1Session.html#ae974dbd0a50bb0d3b62f327276f07515" title="Remove a device from the session. ">remove()</a></code> to manipulate this set. <br /></td></tr>
<tr class="separator:a1ed604b80d9b49ee18dbcbbb3d8921d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b886bf85b1522b0a070585dc0d1717"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a75b886bf85b1522b0a070585dc0d1717"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a75b886bf85b1522b0a070585dc0d1717">m_active_devices</a></td></tr>
<tr class="memdesc:a75b886bf85b1522b0a070585dc0d1717"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of devices currently streaming samples. <br /></td></tr>
<tr class="separator:a75b886bf85b1522b0a070585dc0d1717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15a57501ec06fbfda3f4963531cedc4e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a15a57501ec06fbfda3f4963531cedc4e"></a>
std::function&lt; void(unsigned)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a15a57501ec06fbfda3f4963531cedc4e">m_completion_callback</a></td></tr>
<tr class="memdesc:a15a57501ec06fbfda3f4963531cedc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback run via the USB thread on session completion. Called with the current value of m_cancellation as an argument, i.e. if the parameter is non-zero we are waiting to complete a cancelled session. <br /></td></tr>
<tr class="separator:a15a57501ec06fbfda3f4963531cedc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f76e8a5a21e15a142ecd362f26e047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae9f76e8a5a21e15a142ecd362f26e047"></a>
std::function&lt; void(<a class="el" href="classsmu_1_1Device.html">Device</a> *device)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ae9f76e8a5a21e15a142ecd362f26e047">m_hotplug_detach_callback</a></td></tr>
<tr class="memdesc:ae9f76e8a5a21e15a142ecd362f26e047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on the USB thread when a device is plugged into the system. <br /></td></tr>
<tr class="separator:ae9f76e8a5a21e15a142ecd362f26e047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81a2e09b02eac75dc682809660b8f718"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a81a2e09b02eac75dc682809660b8f718"></a>
std::function&lt; void(<a class="el" href="classsmu_1_1Device.html">Device</a> *device)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a81a2e09b02eac75dc682809660b8f718">m_hotplug_attach_callback</a></td></tr>
<tr class="memdesc:a81a2e09b02eac75dc682809660b8f718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Callback called on the USB thread when a device is removed from the system. <br /></td></tr>
<tr class="separator:a81a2e09b02eac75dc682809660b8f718"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a90204dc702f55c24e75c2c59769981fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a90204dc702f55c24e75c2c59769981fe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a90204dc702f55c24e75c2c59769981fe">start_usb_thread</a> ()</td></tr>
<tr class="memdesc:a90204dc702f55c24e75c2c59769981fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Spawn thread for USB transaction handling. <br /></td></tr>
<tr class="separator:a90204dc702f55c24e75c2c59769981fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5069bf9f14d7abf5eb243ccde39eff"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a7c5069bf9f14d7abf5eb243ccde39eff">probe_device</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a7c5069bf9f14d7abf5eb243ccde39eff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify devices supported by libsmu.  <a href="#a7c5069bf9f14d7abf5eb243ccde39eff">More...</a><br /></td></tr>
<tr class="separator:a7c5069bf9f14d7abf5eb243ccde39eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1138e18e7b8ff62cd9aa96a6a80e1f0a"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="classsmu_1_1Device.html">Device</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a1138e18e7b8ff62cd9aa96a6a80e1f0a">find_existing_device</a> (libusb_device *usb_dev)</td></tr>
<tr class="memdesc:a1138e18e7b8ff62cd9aa96a6a80e1f0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find an existing, available device.  <a href="#a1138e18e7b8ff62cd9aa96a6a80e1f0a">More...</a><br /></td></tr>
<tr class="separator:a1138e18e7b8ff62cd9aa96a6a80e1f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae6e0c6984c7567b31b7a7f544b27f9c4"></a>
unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ae6e0c6984c7567b31b7a7f544b27f9c4">m_cancellation</a> = 0</td></tr>
<tr class="memdesc:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag used to cancel all pending USB transactions for devices in a session. <br /></td></tr>
<tr class="separator:ae6e0c6984c7567b31b7a7f544b27f9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d36179ca4dcc9859025e5a97858196c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0d36179ca4dcc9859025e5a97858196c"></a>
std::atomic&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a0d36179ca4dcc9859025e5a97858196c">m_usb_thread_loop</a></td></tr>
<tr class="memdesc:a0d36179ca4dcc9859025e5a97858196c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for controlling USB event handling. <br /></td></tr>
<tr class="separator:a0d36179ca4dcc9859025e5a97858196c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2f32749c5d2837c433ca0817e6a5e08"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab2f32749c5d2837c433ca0817e6a5e08"></a>
std::thread&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ab2f32749c5d2837c433ca0817e6a5e08">m_usb_thread</a></td></tr>
<tr class="memdesc:ab2f32749c5d2837c433ca0817e6a5e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">USB thread handling pending events in blocking mode. <br /></td></tr>
<tr class="separator:ab2f32749c5d2837c433ca0817e6a5e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4570213847cccd9021c1e51b72fec27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac4570213847cccd9021c1e51b72fec27"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ac4570213847cccd9021c1e51b72fec27">m_lock</a></td></tr>
<tr class="memdesc:ac4570213847cccd9021c1e51b72fec27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock for session completion. <br /></td></tr>
<tr class="separator:ac4570213847cccd9021c1e51b72fec27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a21ca39f64d0f74e80a8d3e6e7e14e949"></a>
std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a21ca39f64d0f74e80a8d3e6e7e14e949">m_lock_devlist</a></td></tr>
<tr class="memdesc:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="mdescLeft">&#160;</td><td class="mdescRight">Lock for the available device list. All code that references m_available_devices needs to acquire this lock before accessing it. <br /></td></tr>
<tr class="separator:a21ca39f64d0f74e80a8d3e6e7e14e949"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dc155db0e9ead7132fa8f92a66f0361"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3dc155db0e9ead7132fa8f92a66f0361"></a>
std::condition_variable&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#a3dc155db0e9ead7132fa8f92a66f0361">m_completion</a></td></tr>
<tr class="memdesc:a3dc155db0e9ead7132fa8f92a66f0361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks on m_lock until session completion is finished. <br /></td></tr>
<tr class="separator:a3dc155db0e9ead7132fa8f92a66f0361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14d22795713d4489ac106c2a31805b1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad14d22795713d4489ac106c2a31805b1"></a>
libusb_context *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsmu_1_1Session.html#ad14d22795713d4489ac106c2a31805b1">m_usb_ctx</a></td></tr>
<tr class="memdesc:ad14d22795713d4489ac106c2a31805b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">libusb context related with a session. This allows for segregating libusb usage so external users can also use libusb without interfering with internal usage. <br /></td></tr>
<tr class="separator:ad14d22795713d4489ac106c2a31805b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Generic session class. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="acf9004a90c79aeb7ea72d673a0eb80c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsmu_1_1Device.html">Device</a>* smu::Session::add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a device to the session. This method may not be called while the session is active. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>The device to be added to the session. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the added device is returned. </dd>
<dd>
On error, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a08380597da395595965e7c118e96619b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::add_all </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shim to add all available devices to a session. This method may not be called while the session is active. </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, the number of devices that couldn't be added to the session are returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a4fc6bf82a0b11fa8b824136b36cdab"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool smu::Session::cancelled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine the cancellation status of a session. </p>
<dl class="section return"><dt>Returns</dt><dd>True, if the session has been cancelled (usually from explicitly calling <a class="el" href="classsmu_1_1Session.html#a5d2654f6a32cf70410a59fbecfce29be" title="Cancel capture and block waiting for it to complete. ">cancel()</a> or cancelled USB transactions). </dd>
<dd>
False, if the session hasn't been started, is running, or has been stopped successfully. </dd></dl>

</div>
</div>
<a class="anchor" id="a894b5e950deb4a5104a12c73cbfd91c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::configure </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Configure the session's sample rate. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>The requested sample rate for the session. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. This method may not be called while the session is active. </dd></dl>

</div>
</div>
<a class="anchor" id="a3d2d4a00c48cd30453a843f267ef49d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smu::Session::destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from the list of available devices. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device to be removed from the available list. Devices are automatically added to this list on attach. Devices must be removed from this list on detach. This method may not be called while the session is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1138e18e7b8ff62cd9aa96a6a80e1f0a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsmu_1_1Device.html">Device</a>&gt; smu::Session::find_existing_device </td>
          <td>(</td>
          <td class="paramtype">libusb_device *&#160;</td>
          <td class="paramname"><em>usb_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Find an existing, available device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usb_dev</td><td>libusb device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the usb device relates to an existing, available device the <a class="el" href="classsmu_1_1Device.html" title="Generic device class. ">Device</a> is returned, otherwise NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a3538a3cff8a463ba7ee89efe2e29485a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smu::Session::flash_firmware </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Update device firmware for a given device. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">file</td><td>Firmware file started for deployment to the device. </td></tr>
    <tr><td class="paramname">device</td><td>The <a class="el" href="classsmu_1_1Device.html" title="Generic device class. ">Device</a> targeted for updating. If device is NULL the first attached device in a session will be used instead. If no configured devices are found, devices in SAM-BA bootloader mode are searched for and the first matching device is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>for various USB failures causing aborted flashes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a84af66d26dcf13f1ffd4c3319bb1acf8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsmu_1_1Device.html">Device</a>* smu::Session::get_device </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serial</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the device matching a given serial from the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">serial</td><td>A string of a device's serial number. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, the matching device is returned. </dd>
<dd>
If no match is found, NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a7c5069bf9f14d7abf5eb243ccde39eff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;<a class="el" href="classsmu_1_1Device.html">Device</a>&gt; smu::Session::probe_device </td>
          <td>(</td>
          <td class="paramtype">libusb_device *&#160;</td>
          <td class="paramname"><em>usb_dev</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify devices supported by libsmu. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">usb_dev</td><td>libusb device </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If the usb device relates to a supported device the <a class="el" href="classsmu_1_1Device.html" title="Generic device class. ">Device</a> is returned, otherwise NULL is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ae974dbd0a50bb0d3b62f327276f07515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smu::Session::remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsmu_1_1Device.html">Device</a> *&#160;</td>
          <td class="paramname"><em>device</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a device from the session. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">device</td><td>A device to be removed from the session. This method may not be called while the session is active. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa2e7b6d5f7617306ea547c3cb574a351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smu::Session::run </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the currently configured capture and wait for it to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Number of samples to capture until we stop. If 0, run in continuous mode. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="acc70d95d0c0e95be86eb5f4e1969b178"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int smu::Session::scan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scan system for all supported devices. Updates the list of available, supported devices for the session (m_available_devices). </p>
<dl class="section return"><dt>Returns</dt><dd>On success, 0 is returned. </dd>
<dd>
On error, a negative errno code is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a89f53f67b1ba9bf64b3d9b7010fa9a2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void smu::Session::start </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>samples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start the currently configured capture, but do not wait for it to complete. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">samples</td><td>Number of samples to capture until we stop. If 0, run in continuous mode. Once started, the only allowed <a class="el" href="classsmu_1_1Session.html" title="Generic session class. ">Session</a> methods are <a class="el" href="classsmu_1_1Session.html#a5d2654f6a32cf70410a59fbecfce29be" title="Cancel capture and block waiting for it to complete. ">cancel()</a> and <a class="el" href="classsmu_1_1Session.html#a27549d952e18e7561e2a16fe8800273a" title="Block until all devices have completed, then turn off the devices. ">end()</a> until the session has stopped. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/timh/code/adi/libsmu/include/libsmu/<a class="el" href="libsmu_8hpp_source.html">libsmu.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jul 11 2016 08:53:29 for libsmu by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
